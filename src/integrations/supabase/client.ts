
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { RpcFunctionReturnTypes } from '@/types/supabase';

const SUPABASE_URL = "https://pqkzybnagdobradtlwpq.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBxa3p5Ym5hZ2RvYnJhZHRsd3BxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDYzNDQ4NDAsImV4cCI6MjA2MTkyMDg0MH0.pr404v2XHGfdeo_ngSCnt4BOD-sUuzbpjktxYaR_4_U";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Extend the supabase client type to include our custom RPC functions
type SupabaseClientWithRpc = ReturnType<typeof createClient<Database>> & {
  rpc<T extends keyof RpcFunctionReturnTypes>(
    fn: T,
    params?: Record<string, any>
  ): { data: RpcFunctionReturnTypes[T] | null; error: any };
};

// Create Supabase client with explicit persistence config
export const supabase = createClient<Database>(
  SUPABASE_URL,
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      // Explicitly use localStorage for persistent sessions
      storage: localStorage,
      // Reduce debug mode to only show critical messages
      debug: false,
      // Add detectSessionInUrl option to help with token processing
      detectSessionInUrl: true,
      // Ensure a longer expiry margin for token refresh
      flowType: 'implicit'
    },
    // Add global error handler for network issues
    global: {
      fetch: (...args: Parameters<typeof fetch>) => {
        return fetch(...args).catch(err => {
          console.error("Network error in Supabase request:", err);
          throw err;
        });
      }
    },
    // Increase realtime timeout to ensure connection stability
    realtime: {
      timeout: 60000
    }
  }
) as unknown as SupabaseClientWithRpc;

/**
 * Enhanced utility to check RLS access for debugging
 */
export const checkRlsAccess = async () => {
  try {
    console.log("Testing RLS access...");
    
    // First check if user is authenticated
    const { data: userData, error: userError } = await supabase.auth.getUser();
    if (userError || !userData?.user) {
      console.error("User not authenticated:", userError);
      return { 
        success: false, 
        error: userError || "No authenticated user found",
        message: "User not authenticated" 
      };
    }
    
    console.log("Authenticated user:", userData.user.id);
    console.log("Auth session check:", await checkAuthSession());
    
    // Test multiple tables to find which one might be causing issues
    const tableNames = ['categories', 'expenses', 'payment_sources'] as const;
    const results: Record<string, any> = {};
    
    for (const tableName of tableNames) {
      console.log(`Testing RLS access for ${tableName}...`);
      
      try {
        const { data, error, count } = await supabase
          .from(tableName)
          .select('*', { count: 'exact', head: true });
          
        if (error) {
          console.error(`RLS check for ${tableName} failed:`, error);
          results[tableName] = { success: false, error };
        } else {
          console.log(`RLS check for ${tableName} passed! Count:`, count);
          results[tableName] = { success: true, count };
        }
      } catch (e) {
        console.error(`Error checking RLS for ${tableName}:`, e);
        results[tableName] = { success: false, error: e };
      }
    }
    
    // Test INSERT capability using a proper UUID instead of a string ID
    try {
      console.log("Testing INSERT capability for expenses...");
      const testId = crypto.randomUUID(); // Generate a proper UUID
      const { error: insertError } = await supabase
        .from('expenses')
        .insert({
          id: testId,
          title: 'Test Expense',
          amount: 100,
          date: new Date().toISOString(),
          payment_type: 'one-time',
          user_id: userData.user.id
        })
        .select();
      
      if (insertError) {
        console.error("INSERT test failed:", insertError);
        results['insert_test'] = { success: false, error: insertError };
      } else {
        console.log("INSERT test successful!");
        results['insert_test'] = { success: true };
        
        // Clean up test data
        const { error: deleteError } = await supabase
          .from('expenses')
          .delete()
          .eq('id', testId);
          
        if (deleteError) {
          console.error("Failed to clean up test data:", deleteError);
        }
      }
    } catch (e) {
      console.error("Error testing INSERT capability:", e);
      results['insert_test'] = { success: false, error: e };
    }
    
    // Check auth.uid() using our helper function
    try {
      const { data: authData, error: authError } = await supabase
        .rpc('get_auth_uid');
        
      if (authError) {
        console.error("Failed to get auth.uid():", authError);
        results['auth_uid'] = { success: false, error: authError };
      } else {
        console.log("Current auth.uid():", authData);
        console.log("Current user.id:", userData.user.id);
        results['auth_uid'] = { success: true, auth_uid: authData, user_id: userData.user.id };
      }
    } catch (e) {
      console.error("Error checking auth.uid():", e);
      results['auth_uid'] = { success: false, error: e };
    }
    
    // Determine overall success status
    const allTablesSuccess = tableNames.every(table => results[table]?.success);
    const authUidSuccess = results['auth_uid']?.success;
    const insertSuccess = results['insert_test']?.success;
    
    // Return comprehensive result
    const authUidMatch = results['auth_uid']?.success ? 
      results['auth_uid']?.auth_uid === userData.user.id : false;
      
    return {
      success: allTablesSuccess && authUidSuccess && insertSuccess, 
      all_tables_accessible: allTablesSuccess,
      auth_uid_working: authUidSuccess,
      insert_working: insertSuccess,
      tables: results,
      auth_uid: results['auth_uid']?.auth_uid,
      user_id: userData.user.id,
      match: authUidMatch,
      message: !allTablesSuccess ? "One or more tables inaccessible" : 
               !authUidSuccess ? "Failed to verify auth.uid()" :
               !insertSuccess ? "Failed to insert test data" :
               !authUidMatch ? "auth.uid() doesn't match user ID" : 
               "All checks passed"
    };
    
  } catch (e) {
    console.error("Error in checkRlsAccess:", e);
    return { success: false, error: e, message: "Error in RLS check function" };
  }
};

/**
 * Helper function to check current auth session status
 */
const checkAuthSession = async () => {
  try {
    const { data: sessionData, error } = await supabase.auth.getSession();
    if (error) {
      return { success: false, error };
    }
    
    if (!sessionData.session) {
      return { success: false, message: "No active session" };
    }
    
    const expiresAt = sessionData.session.expires_at;
    const now = Math.floor(Date.now() / 1000);
    const expiresInSeconds = expiresAt - now;
    const expiresInMinutes = Math.floor(expiresInSeconds / 60);
    
    return {
      success: true,
      session: sessionData.session,
      expires_in: {
        seconds: expiresInSeconds,
        minutes: expiresInMinutes
      }
    };
  } catch (e) {
    return { success: false, error: e };
  }
};

/**
 * Refreshes the current session token if needed
 * @returns true if successful, false if failed or not needed
 */
export const refreshSessionIfNeeded = async (): Promise<boolean> => {
  try {
    const { data: sessionData } = await supabase.auth.getSession();
    if (!sessionData.session) return false;
    
    const expiresAt = sessionData.session.expires_at;
    const now = Math.floor(Date.now() / 1000);
    const expiresInMinutes = Math.floor((expiresAt - now) / 60);
    
    // If token expires in less than 10 minutes, refresh it
    if (expiresInMinutes < 10) {
      console.log("Session token expiring soon, refreshing...");
      const { data, error } = await supabase.auth.refreshSession();
      if (error) {
        console.error("Failed to refresh session:", error);
        return false;
      }
      console.log("Session refreshed successfully!");
      return true;
    }
    
    return true;
  } catch (e) {
    console.error("Error in refreshSessionIfNeeded:", e);
    return false;
  }
};

/**
 * Utility to force refresh data from Supabase
 * This can be used when data isn't showing up correctly
 */
export const forceRefreshData = async (): Promise<boolean> => {
  try {
    // First ensure session is valid
    const sessionRefreshed = await refreshSessionIfNeeded();
    if (!sessionRefreshed) {
      console.warn("Cannot refresh data: invalid session");
      return false;
    }
    
    // Clear any local caches if needed
    // This helps when stale data might be in the Supabase client cache
    await supabase.auth.refreshSession();
    
    console.log("Data refresh preparation complete");
    return true;
  } catch (e) {
    console.error("Error in forceRefreshData:", e);
    return false;
  }
};
